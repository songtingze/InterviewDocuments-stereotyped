# 并发总结

## 进程与线程

- 定义

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。

与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

**一个 Java 程序的运行是 main 线程和多个其他线程同时运行**。

- 区别

1. **根本区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
2. **切换时资源开销**：每个进程都有**独立的代码和数据空间（程序上下文）**，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程**共享代码和数据空间（进程的**堆**和**方法区**）**，每个线程都有自己**独立的运行栈和程序计数器（PC）**，线程之间切换的开销小。
3. **包含关系**：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
4. **内存分配（独立与共享）**：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。
5. **影响关系（健壮性）**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是**一个线程崩溃整个进程都死掉**。所以多进程要比多线程健壮。
6. **执行过程**：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行。

### 为什么要使用多线程?

- **计算机底层角度**：线程间的切换和调度的成本远远小于进程。多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
- **当代互联网发展趋势**：多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。
- **单核时代**：为了提高单进程利用 CPU 和 IO 系统的效率。 单核多线程对于IO密集型任务效率提升效果更加显著；对于CPU密集型任务反而会由于线程切换而增大开销，不利于效率提高。
- **多核时代**: 核时代多线程主要是为了提高进程利用多核 CPU 的能力。多个CPU可以同时执行一个复杂的任务。

### 使用多线程可能带来什么问题?

并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：**内存泄漏、死锁、线程不安全**等等。

### 线程安全与不安全

线程安全和不安全是在**多线程**环境下对于**同一份数据的访问**是否能够保证其**正确性和一致性**的描述。

线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。

线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致**数据混乱、错误或者丢失**。

## Thread

### 线程的生命周期和状态?

- NEW: 初始(新建)状态，线程被创建出来但没有被调用 `start()` 。Thread t = new MyThread();

- RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态。包括**就绪状态（Runnable）**和**运行状态（Running）**。
  - 就绪状态：当调用线程对象的start()方法，线程即进入就绪状态。说明此线程已经做好了准备，随时等待CPU调度执行。
  - 运行状态：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。就绪状态是进入到运行状态的唯一入口。

- BLOCKED：阻塞状态 - 同步阻塞，获取synchronized同步锁失败，需要等待锁释放。

- WAITING：等待状态 - 等待阻塞，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。

- TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。当sleep()状态超时. join()等待线程终止或者超时. 或者I/O处理完毕时，线程重新转入就绪状态。

- TERMINATED：终止状态，表示该线程已经运行完毕。

join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。